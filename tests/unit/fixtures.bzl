def _fixture_impl(ctx):
    out = ctx.actions.declare_file(ctx.label.name)
    args = ctx.attr.args + [ctx.file.fixture.path, "-o", out.path]
    ctx.actions.run(
        inputs = [ctx.file.fixture],
        outputs = [out],
        arguments = args,
        progress_message = "Generating fixture %s" % out.short_path,
        executable = ctx.executable.compiler,
    )
    return [DefaultInfo(files = depset([out]))]

fixture = rule(
    implementation = _fixture_impl,
    attrs = {
        "compiler": attr.label(executable = True, mandatory = True, cfg = "exec"),
        "args": attr.string_list(mandatory = True),
        "fixture": attr.label(mandatory = True, allow_single_file = True),
    },
)

HEADER = """
// !!! Autogenerated file !!!
namespace mull {
namespace fixtures {
"""

FOOTER = """
} // namespace fixtures
} // namespace mull
"""

CODE = """
__attribute__((used)) static const char* {NAME}_path() {{
  return "{PATH}";
}}
"""

def _fixtures_header_impl(ctx):
    chunks = []
    for fixture in ctx.files.fixtures:
        name = fixture.short_path.replace("/", "_").replace(".", "_")
        chunks.append(CODE.format(NAME = name, PATH = fixture.short_path))
    content = HEADER + "\n".join(chunks) + FOOTER
    ctx.actions.write(ctx.outputs.header, content)

fixtures_header = rule(
    implementation = _fixtures_header_impl,
    attrs = {
        "fixtures": attr.label_list(mandatory = True, allow_files = True),
        "header": attr.output(),
    },
)
